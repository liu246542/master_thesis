% !Mode:: "TeX:UTF-8"

% !TEX root = ../main.tex

\chapter{背景知识及相关密码学原语介绍}[Background]

在这一章中，我们主要介绍一些基本的密码学原语，包括对称和非对称密码体制、数字签名、双线性映射、环签名、零知识证明、承诺机制及密码哈希函数。
另外我们还介绍了第四章中需要使用的两个方案，一个是2001年Boneh和Franklin提出的基于身份的加密方案\cite{boneh2001identity}，另一个是2005年由Chow，Yiu和Hui提出的基于身份的环签名方案\cite{chow2005efficient}。

\section{对称密码体制}[Private-key Cryptography]
对称密码体制，又称私钥密码体制，也就是说在这种密码体制中，密钥是不公开的。
“对称”指的是通信双方拥有相同的密钥，密钥通常是被用于加密和解密信息。
对称密码体制可以提供数据加解密和信息验证两种功能，分别用于保证数据的安全性和完整性。
在本文中，我们使用$\mathcal{ENC}(\cdot)$和$\mathcal{DEC}(\cdot)$表示现实生活中的对称加密和解密算法，如AES算法。

假设明文空间为$\mathcal{M}$，密文空间为$\mathcal{C}$，密钥空间为$\mathcal{K}$。
在拥有对称密钥$k\in\mathcal{K}$和明文$m\in\mathcal{M}$的情况下，加密明文$m$的过程可以表示为：
\begin{equation}
c=\mathcal{ENC}_k(m)
\end{equation}
类似地，解密密文$c$的过程可以表示为：
\begin{equation}
m'=\mathcal{DEC}_k(c)
\end{equation}
在使用同一个密钥$k$的情况下，我们有$m'=m$始终成立。

通信双方能够借助加密和解密算法为信息的安全性提供保障，即使它们是在不安全的信道中进行传输的。
由于信道中传输的都是密文，窃听者并不能从中获取有用的信息，换句话说就是能够很好地防止被动攻击。
但是仅仅依赖加密和解密不能保证传输信息的完整性，我们还需要防止传输的信息被篡改。
像这种可以篡改消息的攻击方式我们一般称为主动攻击。

在对称密码体制中，为了确保能够抵抗主动攻击，通常需要使用消息验证码（Message Authentication Code，MAC）。
记$\mathcal{HMAC}(\cdot)$为一个基于哈希函数的消息验证码算法。
那么，对于消息$m$，生成消息验证码的过程可以表示为：
\begin{equation}
\Sigma=\mathcal{HMAC}_k(m)
\end{equation}
欲使通信双方在进行信息传输的过程中能抵抗主动攻击，一般先加密明文，再对加密后的密文生成消息验证码（Encrypt-then-MAC）\cite{krawczyk2001order}。

\section{公钥密码体制}[Public Cryptography]

公钥密码，又称非对称密码，所谓的“非对称”是相对“对称密码学”而言的，意思是在这种体制中存在公钥和私钥这两种密钥。
公钥一般是公开的，所有人都可见的，被用于对信息的加密或验证；
私钥则是用户自己私密保管的，一般是用来解密或签名。
在对称密码体制中，加密和解密使用的是同一个密钥，这个密钥是需要通信双方保密的，因此存在着密钥协商的问题，即如何安全地为通信双方传递这个密钥。
在公钥密码体制中就不存在这个问题，因为每个用户可以产生一对密钥，不用密钥协商，只需要公开自己的公钥，同时保管好自己的私钥。这样的做法显然简化了密钥的管理。

公钥密码体制主要提供公钥加密和数字签名两种功能。
在效率方面，公钥加密方案不如对称加密方案。
因此在实际生活中，一般使用公钥加密机制来发起通信，通过三次握手协议完成密钥协商。在通信双方获取到相同密钥时，再使用对称密码机制进行数据的传输。

在安全性方面，公钥密码体制主要依赖于数论中的困难问题假设，比如大整数分解问题和离散对数问题。在现代密码学体系中，我们称一个问题是困难问题，意味着对于所有概率多项式时间（Probabilistic Polynomial Time）的算法$\mathcal{A}$来说，通过$\mathcal{A}$来解决这个困难问题的概率总是可以忽略不计的。在这里，我们使用$\mathsf{negl}(n)$来表示一个可忽略函数，它的定义如下：

如果对于所有的正多项式函数$p(n)$，总存在$N$使得当整数$n>N$时，有
\begin{equation}
\mathsf{negl}(n)<\frac{1}{p(n)}
\end{equation}
始终成立，那么我们称$\mathsf{negl}(n)$是一个可忽略函数。

由此我们记$\mathsf{Sol}_{\mathcal{A}}(n)=1$为利用算法$\mathcal{A}$成功求解一个困难问题的事件，那么对于困难问题的定义可以描述为：
对于所有的概率多项式时间算法$\mathcal{A}$，我们都可以找到一个可忽略函数$\mathsf{negl}(n)$使得公式（2-5）总成立。
\begin{equation}
\Pr[\mathsf{Sol}_\mathcal{A}(n)=1]\leq\mathsf{negl}(n)
\end{equation}

第一个被提出并得到广泛应用的对称密码学算法是RSA算法，其安全性基于大整数分解问题。
RSA算法既能完成对信息的加密，也能实现数字签名\cite{rivest1978method}。
由于易于实现等特性，RSA算法在今天仍被广泛使用。

基于离散对数问题的主要有ElGamal公钥密码体制和椭圆曲线密码体制，现在的数字签名标准DSS就是基于ElGamal密码体制。
而椭圆曲线密码体制是目前除了RSA之外，应用最为广泛的公钥密码体制之一。相比于RSA，椭圆曲线密码可以使用长度更短的密钥来达到相同的安全程度，比较适合在存储能力有限的应用场景中。

\section{数字签名}[Signature]

数字签名作为公钥密码学中的重要组成部分，主要作用是保证信息的完整性，同时也可以用于确定信息发送者身份的真实性。
一般情况下，发送者使用自己的私钥对需要发送的信息进行签名，接收者可以使用发送者的公钥完成验证。
一个完整的签名机制主要包含以下三个算法$(\mathsf{Gen},\mathsf{Sig},\mathsf{Vrf})$，具体的过程如下：

\begin{itemize}
  \item 初始化阶段：密钥生成算法$\mathsf{Gen}$通过输入一个安全参数$\kappa$产生一对密钥$(pk,sk)$，我们将这对密钥分别称为公钥和私钥。签名者可以公开公钥，并保管好私钥；
  \item 签名阶段：签名者运行签名算法$\mathsf{Sig}$：通过输入私钥$sk$及需要签名的信息$m$，可以生成关于此消息的一个签名$\sigma$。我们可以写成$\sigma\leftarrow \mathsf{Sig}_{sk}(m)$的形式；
  \item 验证阶段：验证者在收到消息$m$及对应的签名$\sigma$后，可以通过输入签名者的公钥$pk$，并运行验证算法$\mathsf{Vrf}$，从而生成一个比特$b$，即$b:= \mathsf{Vrf}_{pk}(m,\sigma)$。当$b=1$时，意味着该签名是有效的；反之，$b=0$则意味着该签名是无效的。
\end{itemize}

假设消息集合为$M$，在数字签名中一般需要满足正确性和安全性：

\textbf{正确性：}对于任意的消息$m\in M$，始终满足：
\begin{equation}
\mathsf{Vrf}_{pk}(m,\mathsf{Sig}_{sk}(m))=1
\end{equation}

\textbf{安全性：}安全性的含义是攻击者不能伪造出一个消息的签名，并且能通过验证者的验证。在定义安全性之前，我们需要考虑下面这个游戏：

在这个游戏中，我们有一个挑战者$\mathcal{C}$和一个攻击者$\mathcal{A}$，游戏分为3个步骤：
\begin{itemize}
  \item[1.] 挑战者$\mathcal{C}$运行$\mathsf{Gen}$算法，得到一对密钥$(pk,sk)$；
  \item[2.] $\mathcal{C}$将$pk$发送给$\mathcal{A}$，$\mathcal{A}$通过访问预言机$\mathsf{Sig}_{sk}(\cdot)$，可以得到所需消息的对应签名。我们把$\mathcal{A}$访问过的消息集合记为$\mathcal{Q}$；
  \item[3.] $\mathcal{A}$输出$(m,\sigma)$，如果满足$\mathsf{Vrf}_{pk}(m,\sigma)=1$且$m\notin \mathcal{Q}$，则$\matcal{A}$在此游戏中获胜。
\end{itemize}

对任意的概率多项式时间的$\mathcal{A}$来说，如果其获胜的概率是可忽略不计的（即$\Pr[adv]\leq\mathsf{negl}$，$adv$为$\mathcal{A}$获胜的事件），那么这个签名机制就是安全的。
我们也可以称这种签名方案满足适应性选择消息的存在性不可伪造。

\section{双线性映射}[Bilinear map]

双线性映射也称双线性对，顾名思义，它的作用是把两个群中的元素映射到另一个群中\cite{张方国2016从双线性对到多线性映射}。
一般这两个群指的是椭圆曲线上的加法群。
双线性映射分为Weil对和Tate对两种类型，在早期的研究工作中，它们主要扮演着密码分析的角色。
例如MOV攻击就是通过把椭圆曲线上的加法群中的点映射为另一个乘法群中的元素，从而将椭圆曲线上的离散对数问题归约到有限域中乘法群上的离散对数问题。

自2000年以后，人们开始发现利用双线性映射的特性可以构造出很多新颖有趣的方案，如三方一轮的密钥协商\cite{joux2000one}，基于身份的密码体制\cite{boneh2001identity}和环签名\cite{chow2005efficient}方案等等。
这些方案在云计算、物联网及生物识别等方面都有许多的应用实例。

在双线性映射中存在三个$q$阶循环群$\mathbb{G}_1$，$\mathbb{G}_2$和$\mathbb{G}_T$，$q$是$\kappa$比特长的素数，其中$\mathbb{G}_1$和$\mathbb{G}_2$都是加法群，$\mathbb{G}_T$是乘法群。
我们称映射$e:\mathbb{G}_1\times\mathbb{G}_2\rightarrow \mathbb{G}_T$是一个双线性映射，如果它满足以下这三条性质：
\begin{itemize}
  \item[1.] 双线性性: 对于所有的$P\in \mathbb{G}_1$，$Q\in \mathbb{G}_2$且$a,b\in\mathbb{Z}_q^*$，有$e(aP,bQ)=e(P,Q)^{ab}$；
  \item[2.] 非退化性: 存在$P\in \mathbb{G}_1$，$Q\in \mathbb{G}_2$，满足$e(P,Q)\neq1$。换句话说，如果$P$，$Q$分别是$\mathbb{G}_1$和$\mathbb{G}_2$的生成元，那么$e(P,Q)$也是$\mathbb{G}_T$的生成元；
  \item[3.] 可计算性：对于所有的$P\in\mathbb{G}_1$，$Q\in\mathbb{G}_2$，都存在高效的算法计算$e(P,Q)$。  
\end{itemize}
特别地，如果$\mathbb{G}_1=\mathbb{G}_2$，即$e:\mathbb{G}_1\times \mathbb{G}_1\rightarrow \mathbb{G}_T$，那么我们可以称该双线性映射$e$是对称的，否则是非对称的。

双线性映射$e$的构造可以通过有限域上的超奇异椭圆曲线上的Weil对或Tate对来完成。
在双线性映射上最常见的困难问题假设有计算性双线性Diffie-Hellman问题（Computational Bilinear Diffie-Hellman Problem，CBDH问题）和判定双线性Diffie-Hellman问题（Decisional Bilinear Diffie-Hellman Problem，DBDH问题），其中CBDH问题也是三方一轮的密钥协商方案的安全基础\cite{joux2000one}。

\textbf{CBDH问题：}在给定$P\in\mathbb{G}_1$，$aQ,bQ,cQ\in\mathbb{G}_2$的情况下（其中$a,b,c$均为随机选取的），计算$e(P,Q)^{abc}$。

\textbf{DBDH问题：}在给定$P\in\mathbb{G}_1$，$aQ,bQ,cQ\in\mathbb{G}_2$的情况下（其中$a,b,c$均为随机选取的），给定$h\in\mathbb{G}_2$，判断$h=e(P,Q)^{abc}$是否成立。

这两个问题都属于困难问题，而且都是在离散对数问题的基础上引申得到的。
因此离散对数问题的困难性要大于CBDH问题的困难性，而CBDH问题的困难性大于DBDH问题的困难性。

在密码学的证明中，我们通常利用反证法的思想，并采用归约的方式（Proof by Reduction）来完成形式化的证明。
形式化的证明通常包括困难问题假设，攻击模型的建立和归约论断这三个基本步骤，
通过给出一个攻击者的模型，把攻击者成功攻击的行为归约为可以成功求解某一个困难问题。
在这个过程中，归约论断可以看做形式化的证明中最为核心的部分。

\section{密码哈希函数}

简单地说，密码哈希函数就是一种将比较长的字符串映射为一个长度固定且更短的字符串的函数，这种更短的字符串我们通常称为摘要（Digest）。
密码哈希函数需要满足的一个基本性质是强抗碰撞性（Strong Collision Resilience），也就是说对于一个哈希函数$H:\{0,1\}^*\rightarrow \{0,1\}^\ell$，很难在概率多项式时间内找到一个二元组$(x,x')$，其中$x\neq x'$，使得$H(x)=H(x')$成立。
由这种强抗碰撞性可以引出两个在安全上相对较弱的性质：

\begin{itemize}
  \item[1.] 弱抗碰撞性（Weak Collision Resilience）：对于给定的$x$，很难在概率多项式时间内找到一个$x'$($x'\neq x$)，使得$H(x)=H(x')$成立；
  \item[2.] 单向性（One-Way）：在已知$y\in \{0,1\}^\ell$的情况下，很难在概率多项式时间内找到一个$x$，使得$H(x)=y$成立。
\end{itemize}

哈希函数在日常生活中最广泛的应用是校验文件的完整性，比如消息摘要算法（Message Digest Algorithm，MD5）就是一种哈希函数。
当我们在网上下载文件时，有些网站上会附带源文件的MD5值。
在完成下载后，我们只需要利用MD5算法将本地文件进行一次哈希运算，再通过与源文件MD5值的对比，就可以知道本地的文件是否与源文件保持一致。

另外，哈希函数在数字签名中也扮演着很重要的角色。
为了提高效率，在进行数字签名的时候，通常不是直接对签名信息进行签名，而是先将签名信息作一次哈希运算，再对这个哈希值进行签名。
由于哈希函数的抗碰撞性质，在安全性上可以认为与直接签名具有同等效力。

在进行安全性的证明时，最常见的做法是将密码哈希函数抽象成随机预言机（Random Oracle）模型。
这种思想最早是由Bellare和Rogaway于1993年提出来的\cite{bellare1993random}，它的出现为现代密码学中的安全证明提供了一种较为通用的方法。
对于一个哈希函数$H:\{0,1\}^*\rightarrow\{0,1\}^\ell$，如果它满足以下这三条性质：
\begin{itemize}
  \item[1.] 均匀性：$H$输出的结果在$\{0,1\}^\ell$上均匀分布；
  \item[2.] 确定性：对于同一个输入，$H$输出的结果也相同；
  \item[3.] 有效性：对于给定的输入，$H$总能在多项式时间内计算出结果。
\end{itemize}
那么，我们称此哈希函数$H$为随机预言机。

随机预言机是一种非常理想的模型，它满足的性质要比抗碰撞性和单向性更强。
这种理想化的模型在现实生活中是不存在的，因此我们在使用随机预言机模型证明的安全性在现实中不一定会是安全的。
因为实际使用中，我们是使用密码哈希函数代替随机预言机实现的。
基于随机预言机模型的证明方法可以在一定程度上说明系统的安全性，它的提出方便了对密码系统安全性的证明。
尽管这种方法存在一定的缺陷，但不可否认的是许多基于随机预言机模型下被证明安全的密码系统已经得到广泛的接受\cite{koblitz2015random}。
我们认为只要在密码系统中使用的哈希函数没有比较大的缺陷时，基于随机预言机模型的安全证明是有效的。

\section{零知识证明}[Zero-Knowledge Proof]

零知识证明本质上是一种安全两方计算协议，参与者分别为证明方$P$与验证方$V$。
所谓的“知识”，可以看作是某个困难问题的解，一个论断或对某项服务的权限。
通过零知识证明，证明方$P$可以向验证方$V$证明自己拥有某个“知识”，同时又能确保不泄露有关这个“知识”的任何有效信息，“零知识”就是由此体现出来的。
这种证明方式可以让用户将一些重要的信息隐藏起来，对保护用户的隐私具有重大的意义。

零知识证明最早是由Goldwasser，Micali和Rackoff提出的\cite{goldwasser1989knowledge}，它需要具备以下三个基本性质：
\begin{itemize}
  \item[1.] 完备性： 如果$P$与$V$都是诚实，那么只要遵循这个协议则一定能让$V$相信$P$的论断；
  \item[2.] 合理性： 如果$P$的论断是本身错误的，那么他始终不能通过$V$的验证；
  \item[3.] 零知识性： 在这个证明的过程中，$V$获取不了除了“这个论断是正确的”以外的任何有价值的信息。
\end{itemize}

一般地，零知识证明可以使用类似下面这种形式进行表示\cite{camenisch1997efficient}：
\begin{equation}
PK\{(\alpha):y=g^\alpha\}
\end{equation}

它表示的是，$P$在知道$y$的离散对数$\alpha$的情况下，可以向$V$证明其知道$\alpha$的值，但同时也能保证在完成这个证明后，$V$不知道$\alpha$具体的值是多少。
完成这样的一个证明$P$与$V$要进行3次交互。
为了提高效率，通常可以根据Fiat和Shamir提出的思路\cite{fiat1986prove}将证明的过程简化，简化之后就只需一次交互。
像这种只需要一轮交互即可完成零知识证明的也被称作非交互式（Non-Interactive）零知识证明。
这种方案也通常被拿来用于实现数字签名。

近几年区块链技术的大热也带动了对零知识证明在应用方面的研究。
“零知识”的特性能够很好地解决隐私保护问题。
尤其在个人隐私频频遭到泄露的今天，如何保护个人隐私越来越受到人们关注，零知识证明技术则为解决这一类问题带来了一些启发。

\section{承诺机制}[Commitment Scheme]

承诺机制是一个用途很广泛的密码学原语，在这个机制中也是存在两类实体，我们分别用$P$和$V$来表示。
$P$需要做出一个选择，但他又不希望选择的内容被$V$知道，同时$V$也需要确保$P$不能随意修改他所做的选择。
比如在观看一场球赛的过程中，$P$事先对会获胜的球队进行预测，但他不想让$V$知道他预测的内容。
等到比赛结束后，为了防止$P$作伪，$V$希望$P$没有改变之前的预测内容。

为了解决这种问题，$P$可以事先准备一个带锁的箱子，并妥善保管好钥匙。
在比赛开始之前，先把要预测的内容写在纸上，再放进箱子里，然后将箱子交给$V$。
等到比赛结束后，再把箱子打开。
由于$V$没有钥匙，因此不能知道承诺的内容，$P$也无法修改箱子里的内容。

类似的，在承诺机制中，我们将承诺的内容用$x$表示，并用一个随机数$r$充当钥匙的角色。
完成承诺机制需要使用一个承诺算法$\mathsf{Com}$，那么承诺值$y$可以表示为$y=\mathsf{Com}(x,r)$的形式。
$P$要对$x$进行承诺的话，只需要把$y$的值公开。
等到需要证明之前承诺的内容是$x$的话，只需要再把$r$公开即可。

一个承诺机制需要满足下面两个基本性质：

\begin{itemize}
  \item[1.] 隐藏性（Hiding）： 对于任意的$x,x'$，$\mathsf{Com}(x,U_n)$与$\mathsf{Com}(x',U_n)$是不可区分的，即对于所有的概率多项式时间算法$\mathcal{A}$，区分成功的概率是可忽略不计的；
  \item[2.] 绑定性(Binding)： 对于任意给定的$y$，不论$r$取什么值，最多只能找到一个$x$使得$y=\mathsf{Com}(x,r)$成立。
\end{itemize}

假设$g$与$h$都是阶数为$q$的群$G$的生成元，对于随机数$r\in_R\mathbb{Z}_q^*$，目前主要有两种常见的承诺机制方案：

\begin{itemize}
  \item[1.] Pedersen 承诺方案： $\mathsf{Com}(x,r)=g^xh^r\mathsf{mod}\ q$
  \item[2.] ElGamal 承诺方案： $\mathsf{Com}(x,r)=(g^xh^r \mathsf{mod}\ q,g^r\mathsf{mod}\ q)$
\end{itemize}

第一个方案是完美隐藏（Perfectly Hiding），计算性绑定（Computationally Binding），后一个方案是计算性隐藏（Computationally Hiding），完美绑定的（Perfectly Binding）。

\section{基于身份的加密方案}[IBE]

在传统的非对称密码体制中，我们需要使用CA（Certificate Authority）来确定公钥的身份。
举个例子，当用户Alice在向Bob传递信息的过程中，需要使用Bob的公钥对信息进行加密。
那么Alice就必须要对Bob的公钥进行验证，以确定这个公钥的拥有者就是Bob。
如何保证这个公钥的身份呢？这就是CA的作用。
CA通过向Bob签发证书，可以把Bob的公钥与其身份关联起来。
Shamir在1984年提出了一种不需要CA的加密和签名体制\cite{shamir1984identity}，并且将其命名为基于身份的密码系统（Identity-Based Cryptosystems）。
在基于身份的加密体制中，公钥一般直接与用户的身份信息有关。如Bob的邮箱或其邮箱的哈希值可以直接作为公钥。
Alice事先只需要知道Bob的邮箱就可以获得Bob的公钥，而且不用CA来保证公钥的身份，从而简化了一系列与证书相关的操作。

在基于身份的密码体制中，需要使用一个私钥解析器（Private Key Generator，PKG）来生成用户的私钥。
要构建基于身份的签名机制是相对容易的，但要设计一个功能完备的基于身份的加密方案却不是那么简单。
直到2001年，Boneh和Franklin才提出第一个可证安全且功能完整的基于身份的加密方案\cite{boneh2001identity}，这个方案是基于双线性映射的，其中主要包含以下4个算法：

\begin{itemize}
  \item[1.] $\mathsf{Setup(1^\kappa)}$： 对于输入的安全参数$\kappa$，输出$(\mathbb{G}_1,\mathbb{G}_T,P,q,e,s,PK,H_1)$。
  其中$\mathbb{G}_1$是椭圆曲线上的加法群，$\mathbb{G}_T$是有限域上的乘法群，且$\mathbb{G}_1$和$\mathbb{G}_T$都是阶数为$q$的循环群。
  $P$是$\mathbb{G}_1$的一个生成元，$e:\mathbb{G}_1\times\mathbb{G}_1\rightarrow \mathbb{G}_T$是一个双线性映射。
  $s$是由系统随机选取的，即$s\in_R \mathbb{Z}_q^*$。
  $PK$是系统的公钥，且$PK=s\cdot P$。
  $H_1$是一个Map-to-Point的密码哈希函数，且$H_1:\{0,1\}^*\rightarrow\mathbb{G}_1$。
  初始化完成之后，系统将$s$作为主私钥（Master Secret Key）保存起来，并公开$(\mathbb{G}_1,\mathbb{G}_T,P,q,e,PK,H_1)$；
  \item[2.] $\mathsf{KeyGen}(ID_i)$： 对于身份信息为$ID_i$的用户，系统通过运行$\mathsf{KeyGen}$算法可以为其生成一对密钥$(PID_i,PSK_i)$。
  其中，$PID_i$是作为用户的公钥，且$PID_i=H_1(ID_i)$，$PSK_i$是作为用户的私钥，且$PSK_i=s\cdot PID_i$；
  \item[3.] $\mathsf{Enc}(M,PID_i)$： 对于需要加密的明文信息$M\in\mathbb{Z}_q^*$，首先随机选择$r\in_R\mathbb{Z}_q^*$，然后输出密文$C=(rP,M\oplus g_d^r)$，其中$g_d=e(PID_i,PK)$；
  \item[4.] $\mathsf{Dec}(C,PSK_i)$： 对于密文$C=(rP,V)$，计算$M'=V\oplus e(PSK_i,rP)$。
\end{itemize}
根据双线性映射的性质，我们知道：
\begin{equation}
e(PSK_i,rP)=e(s\cdot PID_i, P)=e(r\cdot PID_i, s\cdot P)=e(PID_i,PK)^r=g_d^r
\end{equation}
因此很容易可以得出$M'=M$。另外，此方案已经被证明在CBDH困难问题假设下，满足CCA安全（即能够抵御主动攻击）。

\section{环签名}[Ring signature]

环签名是一种具有匿名性质的签名体制，它最早是由Rivest，Shamir和Tauman于2001年提出的\cite{rivest2001leak}。
在传统的签名体制中，验证方需要使用签名者的公钥来验证信息。
从某种程度上来看，这就暴露了用户的身份信息（因为用户的公钥与身份存在着一定的关联性）。
而在环签名体制中，签名者先需要收集一定数量的公钥，然后再用自己的私钥进行签名，并把最终得到的签名连同签名的内容及用到的公钥列表一起发送给验证者。
由于验证者看到的是一组公钥，因此不能通过这一组公钥判断签名者真正的身份。

环签名的提出很大程度上受到了群签名的启发\cite{chaum1991group}，二者都保证了验证者只知道“此签名为群体中某个成员生成”这一事实，从而很好地保护了用户的隐私。
它们之间最大的不同在于，在群签名体制中存在着群管理员，而群管理员拥有着最高的权限，能够移除旧群成员及为新群成员分配密钥。
在环签名中不存在这样的管理员，也不需要环成员的合作，只需要自己来组建一个群体，因此具有很强的自发性。

这里我们主要介绍一下由Chow，Yiu和Hui等人于2005年提出的基于身份的环签名方案\cite{chow2005efficient}。
这个方案也是在双线性映射上构造的，主要包括以下4个算法：

\begin{itemize}
  \item[1.] $\mathsf{Setup}(1^\kappa)$： 对于输入的安全参数$\kappa$，输出$(\mathbb{G}_1,\mathbb{G}_T,P,q,e,s,PK,H_1,H_2)$，其中参数$(\mathbb{G}_1,\mathbb{G}_T,P,q,e,s,PK,H_1)$与上一节基于身份的加密方案中描述的一致，$H_2$是一个密码哈希函数，且$H_2:\{0,1\}^*\rightarrow\mathbb{Z}_q^*$。
  在初始化完成之后，系统将$s$作为主私钥保存起来，并公开$(\mathbb{G}_1,\mathbb{G}_T,P,q,e,PK,H_1,H_2)$。
  \item[2.] $\mathsf{KeyGen}(ID_\ell)$： 与上一节类似，通过输入签名者的身份信息$ID_\ell$，系统可以生成一对密钥$(PID_\ell,PSK_\ell)$，其中$PID_\ell=H_1(ID_\ell)$，是作为签名者的公钥，$PSK_\ell=s\cdot PID_\ell$，是作为签名者的私钥；
  \item[3.] $\mathsf{Sign}(m,PSK_\ell,L)$： 对于拥有私钥$PSK_\ell$的用户可以使用成员列表$L=\{PID_1,PID_2,...,PID_n\}$来对消息$m$进行签名，其中$1\leq \ell\leq n$。
  对于$1\leq i \leq n$，且$i\neq \ell$，随机选择$U_i\in_R\mathbb{G}_1$，然后计算$h_i=H_2(m||L||U_i)$；
  再随机选取$r_\ell'\in_R\mathbb{Z}_q^*$，并计算$U_\ell=r_\ell'PID_\ell-\sum_{i\neq \ell}\{U_i+h_i PID_i\}$，$h_\ell=H_2(m||L||U_\ell)$和$V=(h_\ell+r_\ell')PSK_\ell$。
  最后输出$(m,\sigma,L)$，其中$\sigma=(\cup_{i=1}^n\{U_i\},V)$；
  \item[4.] $\mathsf{Verify}(m,\sigma,L)$： 对于$1\leq i \leq n$，计算$h_\ell=H_2(m||L||U_i)$，然后检验$e(PK,\sum_{i=1}^n(U_i+h_iPID{_i}))=e(P,V)$是否成立。
\end{itemize}

这个签名方案已经被证明在随机预言机模型下具有适应性选择消息和身份下的存在性不可伪造\cite{chow2005efficient}。

\section{本章小结}[Summary II]

在这一章中，我们首先介绍了对称与非对称密码体制以及一些基础的密码学原语。
对称与非对称密码体制都可以保障在不安全的信道中传输内容的安全性和完整性。
在对称密码体制中，通信双方需要具备相同的密钥，并且可以使用Encrypt-then-MAC的方式抵抗主动攻击。
非对称密码体制由于使用的是不同的密钥，相比于对称密码体制不需要事先的密钥协商，但在效率方面不如对称密码体制。
因此现实生活中通常使用非对称密码体制来完成密钥的协商，通信双方可以通过这种方式得到相同的密钥。
再使用对称密码的方法完成数据的传输。

非对称密码体制使用数字签名来保证数据的完整性。
而基于双线性映射构造的签名方案，得到的签名长度相对较短，且形式较为简洁。
利用双线性映射的性质我们能够相对容易地构造出具有特殊性质的加密和签名方案。
基于双线性映射的方案的安全性都是基于离散对数问题，我们重点介绍了两个在双线性映射上常见的困难问题，一个是CBDH问题，另一个是DBDH问题。
在后面的证明中，我们将基于这些困难问题假设完成安全性的证明。

密码哈希函数在现实生活中比较常见，它需要满足的基本性质就是强抗碰撞性。
这种性质可以引申出两个相对较弱的性质：弱抗碰撞性和单向性。
在进行安全性证明的时候，我们一般将其抽象为随机预言机模型。
随机预言机作为一种比较“强”的理想模型，为密码学理论世界与现实世界之间搭建了一座“桥梁”。
在随机预言机模型下证明的安全在一定程度上可以说明系统在现实生活中的安全性。
在本文中，我们的安全性证明也是基于随机预言机模型下完成的。

零知识证明和承诺机制都是为了保护用户隐私而出现的，但二者针对的问题有很大不同。
这两个密码学原语是构建一个匿名凭证系统的基础，在第三章里会讲述如何使用这两个密码学原语来实现我们所需要的特性。
最后介绍的基于身份的加密和基于身份的环签名都是在第四章中需要用到的，在第四章，我们会详细描述如何把这些方案进行结合，并应用到具体的生活场景中。

这一章介绍的密码学工具在隐私保护和数据安全方面，尤其是在进行身份认证，确保数据的完整性以及实现匿名性的时候有着很广泛的应用。
要构建一个基于属性的凭证系统，我们就需要利用这些工具的优势，以实现所需要满足的性质。